{"ast":null,"code":"// Trend Data API Service\n// Updated to use correct backend URL\nconst API_BASE_URL='https://wki-service-management-app.onrender.com';// Fetch trend data for a specific metric at a specific location\nexport const fetchTrendData=async function(locationId,metric){let months=arguments.length>2&&arguments[2]!==undefined?arguments[2]:12;try{// DEBUG: Log the exact metric name being passed in\nconsole.log(\"TrendAPI: fetchTrendData called with metric: \\\"\".concat(metric,\"\\\" (length: \").concat(metric.length,\")\"));console.log(\"TrendAPI: metric character codes:\",metric.split('').map(c=>\"\".concat(c,\"(\").concat(c.charCodeAt(0),\")\")).join(' '));// CRITICAL: Do not transform the metric name at all - use exactly as passed\nconst trendsUrl=\"\".concat(API_BASE_URL,\"/api/locationMetrics/trends/\").concat(locationId,\"/\").concat(metric,\"?months=\").concat(months);console.log('üîç TrendAPI: Attempting to fetch trends from:',trendsUrl);const trendsResponse=await fetch(trendsUrl);console.log('Trends response status:',trendsResponse.status);console.log('Trends response headers:',Object.fromEntries(trendsResponse.headers.entries()));if(trendsResponse.ok){const responseText=await trendsResponse.text();console.log('Raw response text:',responseText.substring(0,200)+'...');// Check if response looks like HTML (error page)\nif(responseText.trim().startsWith('<!DOCTYPE')||responseText.trim().startsWith('<html')){console.error('üö® TrendAPI: Got HTML response instead of JSON - API endpoint not found!');console.error('üö® TrendAPI: Check if your API routes are properly configured');throw new Error('API endpoint returned HTML instead of JSON');}try{var _result$data,_result$data2;const result=JSON.parse(responseText);console.log('‚úÖ TrendAPI: Successfully parsed JSON response');console.log('‚úÖ TrendAPI: Current value from API:',(_result$data=result.data)===null||_result$data===void 0?void 0:_result$data.currentValue);console.log('‚úÖ TrendAPI: Current period from API:',(_result$data2=result.data)===null||_result$data2===void 0?void 0:_result$data2.currentPeriod);// Validate the response structure\nif(result.data&&Array.isArray(result.data.dataPoints)){return result;}}catch(parseError){console.error('‚ùå TrendAPI: JSON parsing failed:',parseError);console.log('‚ùå TrendAPI: Response was not valid JSON, probably got HTML instead');}}// If trends endpoint doesn't exist, fall back to building trends from uploaded data\nconsole.log('‚ö†Ô∏è TrendAPI: Building trend data from uploaded scorecards...');return await buildTrendFromUploadedData(locationId,metric,months);}catch(error){console.error('‚ùå TrendAPI: Error fetching trend data:',error);// Fall back to building from uploaded data\nreturn await buildTrendFromUploadedData(locationId,metric,months);}};// Build trend data from actual uploaded scorecard data\nconst buildTrendFromUploadedData=async(locationId,metric,months)=>{try{var _dataPoints$,_dataPoints,_dataPoints2,_dataPoints3;console.log(\"\\uD83D\\uDD27 TrendAPI: Building trend for metric \\\"\".concat(metric,\"\\\" at location \\\"\").concat(locationId,\"\\\"\"));// Fetch the actual history of uploaded scorecards\nconst historyUrl=\"\".concat(API_BASE_URL,\"/api/locationMetrics/history\");console.log('Fetching upload history from:',historyUrl);const historyResponse=await fetch(historyUrl);console.log('History response status:',historyResponse.status);if(!historyResponse.ok){throw new Error(\"Failed to fetch upload history: \".concat(historyResponse.status));}const responseText=await historyResponse.text();console.log('History raw response:',responseText.substring(0,200)+'...');// Check if response looks like HTML\nif(responseText.trim().startsWith('<!DOCTYPE')||responseText.trim().startsWith('<html')){console.error('History API returned HTML instead of JSON');throw new Error('History API returned HTML instead of JSON');}let historyData;try{historyData=JSON.parse(responseText);}catch(parseError){console.error('Failed to parse history response as JSON:',parseError);throw new Error('History API returned non-JSON response (probably HTML redirect)');}if(!historyData.success||!historyData.data||!Array.isArray(historyData.data.history)){throw new Error('No upload history available');}const uploadedMonths=historyData.data.history;console.log(\"Found \".concat(uploadedMonths.length,\" actual uploaded months:\"),uploadedMonths.map(u=>\"\".concat(u.month,\" \").concat(u.year)));if(uploadedMonths.length===0){throw new Error('No uploaded scorecard data found');}// Sort uploads by date to ensure proper chronological order\nuploadedMonths.sort((a,b)=>{const dateA=new Date(a.year,getMonthNumber(a.month)-1);const dateB=new Date(b.year,getMonthNumber(b.month)-1);return dateA.getTime()-dateB.getTime();});// Now fetch the actual data for each uploaded month\nconst dataPoints=[];for(const upload of uploadedMonths){try{// For now, we'll use the current endpoint to get the latest data\n// In a real implementation, we'd need an endpoint that returns historical data by month/year\nconsole.log(\"Fetching data for \".concat(upload.month,\" \").concat(upload.year,\" (ID: \").concat(upload.id,\")\"));// Since we don't have a month-specific endpoint yet, we can only show the current/latest data\n// This is a limitation that needs to be addressed in the backend\nconst response=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics\"));if(response.ok){const data=await response.json();let locations=[];if(data&&typeof data==='object'){if('locations'in data){locations=data.locations;}else if('data'in data&&data.data&&'locations'in data.data){locations=data.data.locations;}}const location=locations.find(loc=>{var _loc$name;return((_loc$name=loc.name)===null||_loc$name===void 0?void 0:_loc$name.toLowerCase().replace(/\\s+/g,'-'))===locationId||loc.locationId===locationId;});if(location){const value=extractMetricValue(location,metric);if(value!==null){const uploadDate=new Date(upload.year,getMonthNumber(upload.month)-1,1);dataPoints.push({month:upload.month,year:upload.year,value:value,uploadDate:uploadDate.toISOString()});}}}}catch(error){console.warn(\"Failed to fetch data for \".concat(upload.month,\" \").concat(upload.year,\":\"),error);}}if(dataPoints.length===0){throw new Error(\"No data found for metric \".concat(metric,\" at location \").concat(locationId));}console.log(\"Built trend with \".concat(dataPoints.length,\" REAL data points:\"),dataPoints.map(p=>\"\".concat(p.month,\" \").concat(p.year,\": \").concat(p.value)));// Calculate trend analysis from actual data\nconst firstValue=((_dataPoints$=dataPoints[0])===null||_dataPoints$===void 0?void 0:_dataPoints$.value)||0;const lastValue=((_dataPoints=dataPoints[dataPoints.length-1])===null||_dataPoints===void 0?void 0:_dataPoints.value)||0;const trendDirection=lastValue-firstValue;const analysis={averageChange:dataPoints.length>1?trendDirection/(dataPoints.length-1):0,volatility:calculateVolatility(dataPoints),bestMonth:dataPoints.reduce((best,current)=>current.value>best.value?current:best,dataPoints[0]),worstMonth:dataPoints.reduce((worst,current)=>current.value<worst.value?current:worst,dataPoints[0]),currentVsPrevious:dataPoints.length>1?lastValue-dataPoints[dataPoints.length-2].value:0};return{success:true,data:{metric,locationId,currentValue:lastValue,currentPeriod:\"\".concat((_dataPoints2=dataPoints[dataPoints.length-1])===null||_dataPoints2===void 0?void 0:_dataPoints2.month,\" \").concat((_dataPoints3=dataPoints[dataPoints.length-1])===null||_dataPoints3===void 0?void 0:_dataPoints3.year),trend:trendDirection>2?'improving':trendDirection<-2?'declining':'stable',trendDirection,dataPoints,monthsOfData:dataPoints.length,analysis}};}catch(error){console.error('‚ùå TrendAPI: Error building trend from actual uploaded data:',error);// Return empty response - NO FAKE DATA\nreturn{success:false,data:{metric,locationId,currentValue:0,currentPeriod:'No data',trend:'stable',trendDirection:0,dataPoints:[],monthsOfData:0,analysis:{averageChange:0,volatility:0,bestMonth:{month:'',year:0,value:0,uploadDate:''},worstMonth:{month:'',year:0,value:0,uploadDate:''},currentVsPrevious:0}}};}};// Helper function to convert month name to number\nconst getMonthNumber=monthName=>{const months=['January','February','March','April','May','June','July','August','September','October','November','December'];return months.indexOf(monthName)+1;};// Extract metric value from location data - PRESERVE EXACT METRIC NAMES\nconst extractMetricValue=(location,metric)=>{console.log(\"\\uD83D\\uDD0D TrendAPI: Extracting value for metric \\\"\".concat(metric,\"\\\" from location data\"));console.log(\"\\uD83D\\uDD0D TrendAPI: Available fields in location:\",Object.keys(location));const value=location[metric];console.log(\"\\uD83D\\uDD0D TrendAPI: Raw value for \\\"\".concat(metric,\"\\\":\"),value);if(value===undefined||value===null||value==='N/A'){console.log(\"\\u26A0\\uFE0F TrendAPI: No value found for metric \\\"\".concat(metric,\"\\\"\"));return null;}// Handle percentage values\nif(typeof value==='string'&&value.includes('%')){const parsed=parseFloat(value.replace('%',''));console.log(\"\\u2705 TrendAPI: Parsed percentage value \\\"\".concat(value,\"\\\" to \").concat(parsed));return parsed;}const parsed=parseFloat(value);console.log(\"\\u2705 TrendAPI: Parsed numeric value \\\"\".concat(value,\"\\\" to \").concat(parsed));return isNaN(parsed)?null:parsed;};// Calculate volatility of data points\nconst calculateVolatility=dataPoints=>{if(dataPoints.length<2)return 0;const values=dataPoints.map(p=>p.value);const mean=values.reduce((sum,val)=>sum+val,0)/values.length;const variance=values.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/values.length;return Math.sqrt(variance);};// Fetch all historical data across all locations\nexport const fetchHistoricalData=async()=>{try{// First, get the upload history to see what months are available\nconst historyResponse=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics/history\"));if(!historyResponse.ok){console.warn(\"Backend history endpoint not available (\".concat(historyResponse.status,\")\"));return{success:false,data:{locations:[]}};}const historyData=await historyResponse.json();if(!historyData.success||!historyData.data||!Array.isArray(historyData.data.history)){console.warn('No upload history available');return{success:false,data:{locations:[]}};}const uploadedMonths=historyData.data.history;console.log(\"Found \".concat(uploadedMonths.length,\" actual uploaded months:\"),uploadedMonths.map(u=>\"\".concat(u.month,\" \").concat(u.year)));// Get current data (which represents the latest upload)\nconst currentResponse=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics\"));if(!currentResponse.ok){console.warn(\"Backend data endpoint not available (\".concat(currentResponse.status,\")\"));return{success:false,data:{locations:[]}};}const currentData=await currentResponse.json();let locations=[];if(currentData&&typeof currentData==='object'){if('locations'in currentData){locations=currentData.locations;}else if('data'in currentData&&currentData.data&&'locations'in currentData.data){locations=currentData.data.locations;}}if(!Array.isArray(locations)||locations.length===0){console.warn('No location data found in response');return{success:false,data:{locations:[]}};}// Transform data to show ONLY the actual uploaded months\n// Note: Currently we can only get the latest month's data due to backend limitations\nconst historicalLocations=locations.map(location=>{var _currentData$data,_currentData$data2,_currentData$data3,_location$name;// For now, we can only show one upload (the latest) since the backend doesn't store historical values per month\n// This is a limitation that should be addressed by storing monthly snapshots in the backend\nconst uploads=[{month:((_currentData$data=currentData.data)===null||_currentData$data===void 0?void 0:_currentData$data.month)||new Date().toLocaleDateString('en-US',{month:'long'}),year:((_currentData$data2=currentData.data)===null||_currentData$data2===void 0?void 0:_currentData$data2.year)||new Date().getFullYear(),uploadDate:((_currentData$data3=currentData.data)===null||_currentData$data3===void 0?void 0:_currentData$data3.uploadedAt)||new Date().toISOString(),metrics:{vscCaseRequirements:location.vscCaseRequirements||'N/A',vscClosedCorrectly:location.vscClosedCorrectly||'N/A',ttActivation:location.ttActivation||'N/A',smMonthlyDwellAvg:location.smMonthlyDwellAvg||'N/A',triageHours:location.triageHours||'N/A',triagePercentLess4Hours:location.triagePercentLess4Hours||'N/A',etrPercentCases:location.etrPercentCases||'N/A',percentCasesWith3Notes:location.percentCasesWith3Notes||'N/A',rdsMonthlyAvgDays:location.rdsMonthlyAvgDays||'N/A',smYtdDwellAvgDays:location.smYtdDwellAvgDays||'N/A',rdsYtdDwellAvgDays:location.rdsYtdDwellAvgDays||'N/A'}}];return{locationId:((_location$name=location.name)===null||_location$name===void 0?void 0:_location$name.toLowerCase().replace(/\\s+/g,'-'))||'unknown',locationName:location.name||'Unknown Location',uploads};});console.log(\"Historical data shows \".concat(uploadedMonths.length,\" uploads available, but backend limitation means we can only display latest month's values\"));return{success:true,data:{locations:historicalLocations}};}catch(error){console.error('Error fetching historical data:',error);return{success:false,data:{locations:[]}};}};// Fetch comparison data across locations and time periods\nexport const fetchComparisonData=async function(){let months=arguments.length>0&&arguments[0]!==undefined?arguments[0]:6;let locationId=arguments.length>1?arguments[1]:undefined;try{// First try the dedicated comparison endpoint\nconst params=new URLSearchParams({months:months.toString()});if(locationId){params.append('locationId',locationId);}const comparisonResponse=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics/compare?\").concat(params));if(comparisonResponse.ok){const result=await comparisonResponse.json();if(result.success&&result.data){return result;}}// If comparison endpoint doesn't exist, build comparison from current data\nconsole.log('Building comparison data from current scorecard data...');return await buildComparisonFromCurrentData(months,locationId);}catch(error){console.error('Error fetching comparison data:',error);// Fall back to building from current data\nreturn await buildComparisonFromCurrentData(months,locationId);}};// Build comparison data from current uploaded scorecard data\nconst buildComparisonFromCurrentData=async(months,locationId)=>{try{// Get upload history to see what months are actually available\nconst historyResponse=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics/history\"));if(!historyResponse.ok){console.warn(\"Backend history endpoint not available (\".concat(historyResponse.status,\")\"));return{success:false,data:{metrics:[]}};}const historyData=await historyResponse.json();if(!historyData.success||!historyData.data||!Array.isArray(historyData.data.history)){console.warn('No upload history available for comparison');return{success:false,data:{metrics:[]}};}const uploadedMonths=historyData.data.history;console.log(\"Building comparison from \".concat(uploadedMonths.length,\" actual uploaded months\"));// Fetch current data (represents latest upload)\nconst response=await fetch(\"\".concat(API_BASE_URL,\"/api/locationMetrics\"));if(!response.ok){throw new Error(\"Failed to fetch current data: \".concat(response.status));}const data=await response.json();let locations=[];// Handle different response structures\nif(data&&typeof data==='object'){if('locations'in data){locations=data.locations;}else if('data'in data&&data.data&&'locations'in data.data){locations=data.data.locations;}}if(!Array.isArray(locations)){throw new Error('No location data available');}// Filter by specific location if requested\nif(locationId&&locationId!=='all'){locations=locations.filter(loc=>{var _loc$name2;return((_loc$name2=loc.name)===null||_loc$name2===void 0?void 0:_loc$name2.toLowerCase().replace(/\\s+/g,'-'))===locationId;});}// Build metrics comparison structure - only using real uploaded data\nconst availableMetrics=['vscCaseRequirements','vscClosedCorrectly','ttActivation','smMonthlyDwellAvg','triageHours','triagePercentLess4Hours'];const metrics=availableMetrics.map(metricKey=>({metric:metricKey,locations:locations.map(location=>{var _location$name2;const currentValue=extractMetricValue(location,metricKey)||0;return{locationId:((_location$name2=location.name)===null||_location$name2===void 0?void 0:_location$name2.toLowerCase().replace(/\\s+/g,'-'))||'unknown',locationName:location.name||'Unknown Location',trendData:[],// Empty since backend doesn't store historical snapshots yet\ncurrentValue,trend:'stable'// No trend calculation possible with single data point\n};})}));console.log(\"Comparison limited to current values. Historical trends require \".concat(uploadedMonths.length,\" monthly snapshots.\"));return{success:true,data:{metrics}};}catch(error){console.error('Error building comparison from current data:',error);return{success:false,data:{metrics:[]}};}};// Calculate trend direction and analysis from data points\nexport const calculateTrend=dataPoints=>{if(dataPoints.length<2){return{trend:'stable',direction:0,confidence:0};}// Calculate simple linear regression slope\nconst n=dataPoints.length;const xValues=dataPoints.map((_,index)=>index);const yValues=dataPoints.map(point=>point.value);const sumX=xValues.reduce((a,b)=>a+b,0);const sumY=yValues.reduce((a,b)=>a+b,0);const sumXY=xValues.reduce((sum,x,i)=>sum+x*yValues[i],0);const sumXX=xValues.reduce((sum,x)=>sum+x*x,0);const slope=(n*sumXY-sumX*sumY)/(n*sumXX-sumX*sumX);// Calculate confidence based on R-squared\nconst meanY=sumY/n;const totalSumSquares=yValues.reduce((sum,y)=>sum+Math.pow(y-meanY,2),0);const predictedValues=xValues.map(x=>sumY/n+slope*(x-sumX/n));const residualSumSquares=yValues.reduce((sum,y,i)=>sum+Math.pow(y-predictedValues[i],2),0);const rSquared=1-residualSumSquares/totalSumSquares;// Determine trend based on slope and confidence\nconst confidence=Math.max(0,Math.min(1,rSquared));const threshold=0.1;// Minimum slope threshold for trend detection\nif(Math.abs(slope)<threshold||confidence<0.3){return{trend:'stable',direction:slope,confidence};}return{trend:slope>0?'improving':'declining',direction:slope,confidence};};// Get trend icon based on trend type\nexport const getTrendIcon=trend=>{switch(trend){case'improving':return'üìà';case'declining':return'üìâ';case'stable':return'üìä';default:return'üìä';}};// Get trend color class based on trend type\nexport const getTrendColorClass=trend=>{switch(trend){case'improving':return'text-green-600';case'declining':return'text-red-600';case'stable':return'text-blue-600';default:return'text-gray-600';}};// Format trend analysis for display\nexport const formatTrendAnalysis=analysis=>{const{trend,analysis:data,monthsOfData}=analysis;if(monthsOfData<2){return'Insufficient data for trend analysis';}const changeText=data.currentVsPrevious>0?'increased':'decreased';const changePercent=Math.abs(data.currentVsPrevious).toFixed(1);switch(trend){case'improving':return\"\\uD83D\\uDCC8 Improving trend over \".concat(monthsOfData,\" months. \").concat(changeText,\" \").concat(changePercent,\"% from previous month.\");case'declining':return\"\\uD83D\\uDCC9 Declining trend over \".concat(monthsOfData,\" months. \").concat(changeText,\" \").concat(changePercent,\"% from previous month.\");case'stable':return\"\\uD83D\\uDCCA Stable performance over \".concat(monthsOfData,\" months with minimal variation.\");default:return\"Data available for \".concat(monthsOfData,\" months.\");}};// Add connection test function\nexport const testBackendConnection=async()=>{try{console.log('Testing backend connection...');const testUrl=\"\".concat(API_BASE_URL,\"/api/locationMetrics\");const response=await fetch(testUrl);console.log('Backend test response:',response.status);if(response.ok){var _data$data,_data$data$locations,_data$data2,_data$data2$locations;const data=await response.json();console.log('Backend is responding with JSON data');console.log('Available locations:',((_data$data=data.data)===null||_data$data===void 0?void 0:(_data$data$locations=_data$data.locations)===null||_data$data$locations===void 0?void 0:_data$data$locations.length)||0);// Test metric extraction to verify values are landing on correct cards\nif(((_data$data2=data.data)===null||_data$data2===void 0?void 0:(_data$data2$locations=_data$data2.locations)===null||_data$data2$locations===void 0?void 0:_data$data2$locations.length)>0){const firstLocation=data.data.locations[0];console.log('Testing metric extraction for first location:');console.log('VSC Case Requirements:',firstLocation.vscCaseRequirements);console.log('VSC Closed Correctly:',firstLocation.vscClosedCorrectly);console.log('TT+ Activation:',firstLocation.ttActivation);console.log('SM Monthly Dwell Avg:',firstLocation.smMonthlyDwellAvg);console.log('SM YTD Dwell Avg Days:',firstLocation.smYtdDwellAvgDays);console.log('Triage % < 4 Hours:',firstLocation.triagePercentLess4Hours);console.log('Triage Hours:',firstLocation.triageHours);console.log('ETR % Cases:',firstLocation.etrPercentCases);console.log('% Cases with 3+ Notes:',firstLocation.percentCasesWith3Notes);console.log('RDS Monthly Avg Days:',firstLocation.rdsMonthlyAvgDays);console.log('RDS YTD Dwell Avg Days:',firstLocation.rdsYtdDwellAvgDays);}return true;}else{console.log('Backend returned error status:',response.status);return false;}}catch(error){console.error('Backend connection test failed:',error);return false;}};","map":{"version":3,"names":["API_BASE_URL","fetchTrendData","locationId","metric","months","arguments","length","undefined","console","log","concat","split","map","c","charCodeAt","join","trendsUrl","trendsResponse","fetch","status","Object","fromEntries","headers","entries","ok","responseText","text","substring","trim","startsWith","error","Error","_result$data","_result$data2","result","JSON","parse","data","currentValue","currentPeriod","Array","isArray","dataPoints","parseError","buildTrendFromUploadedData","_dataPoints$","_dataPoints","_dataPoints2","_dataPoints3","historyUrl","historyResponse","historyData","success","history","uploadedMonths","u","month","year","sort","a","b","dateA","Date","getMonthNumber","dateB","getTime","upload","id","response","json","locations","location","find","loc","_loc$name","name","toLowerCase","replace","value","extractMetricValue","uploadDate","push","toISOString","warn","p","firstValue","lastValue","trendDirection","analysis","averageChange","volatility","calculateVolatility","bestMonth","reduce","best","current","worstMonth","worst","currentVsPrevious","trend","monthsOfData","monthName","indexOf","keys","includes","parsed","parseFloat","isNaN","values","mean","sum","val","variance","Math","pow","sqrt","fetchHistoricalData","currentResponse","currentData","historicalLocations","_currentData$data","_currentData$data2","_currentData$data3","_location$name","uploads","toLocaleDateString","getFullYear","uploadedAt","metrics","vscCaseRequirements","vscClosedCorrectly","ttActivation","smMonthlyDwellAvg","triageHours","triagePercentLess4Hours","etrPercentCases","percentCasesWith3Notes","rdsMonthlyAvgDays","smYtdDwellAvgDays","rdsYtdDwellAvgDays","locationName","fetchComparisonData","params","URLSearchParams","toString","append","comparisonResponse","buildComparisonFromCurrentData","filter","_loc$name2","availableMetrics","metricKey","_location$name2","trendData","calculateTrend","direction","confidence","n","xValues","_","index","yValues","point","sumX","sumY","sumXY","x","i","sumXX","slope","meanY","totalSumSquares","y","predictedValues","residualSumSquares","rSquared","max","min","threshold","abs","getTrendIcon","getTrendColorClass","formatTrendAnalysis","changeText","changePercent","toFixed","testBackendConnection","testUrl","_data$data","_data$data$locations","_data$data2","_data$data2$locations","firstLocation"],"sources":["C:/Users/michaela/service-management-app/frontend/src/services/trendApi.ts"],"sourcesContent":["// Trend Data API Service\r\n// Updated to use correct backend URL\r\nconst API_BASE_URL = 'https://wki-service-management-app.onrender.com';\r\n\r\nexport interface TrendDataPoint {\r\n  month: string;\r\n  year: number;\r\n  value: number;\r\n  uploadDate: string;\r\n}\r\n\r\nexport interface TrendAnalysis {\r\n  metric: string;\r\n  locationId: string;\r\n  currentValue: number;\r\n  currentPeriod: string;\r\n  trend: 'improving' | 'declining' | 'stable';\r\n  trendDirection: number; // Positive for improving, negative for declining\r\n  dataPoints: TrendDataPoint[];\r\n  monthsOfData: number;\r\n  analysis: {\r\n    averageChange: number;\r\n    volatility: number;\r\n    bestMonth: TrendDataPoint;\r\n    worstMonth: TrendDataPoint;\r\n    currentVsPrevious: number;\r\n  };\r\n}\r\n\r\nexport interface HistoricalDataResponse {\r\n  success: boolean;\r\n  data: {\r\n    locations: Array<{\r\n      locationId: string;\r\n      locationName: string;\r\n      uploads: Array<{\r\n        month: string;\r\n        year: number;\r\n        uploadDate: string;\r\n        metrics: Record<string, any>;\r\n      }>;\r\n    }>;\r\n  };\r\n}\r\n\r\nexport interface TrendResponse {\r\n  success: boolean;\r\n  data: TrendAnalysis;\r\n}\r\n\r\nexport interface ComparisonResponse {\r\n  success: boolean;\r\n  data: {\r\n    metrics: Array<{\r\n      metric: string;\r\n      locations: Array<{\r\n        locationId: string;\r\n        locationName: string;\r\n        trendData: TrendDataPoint[];\r\n        currentValue: number;\r\n        trend: string;\r\n      }>;\r\n    }>;\r\n  };\r\n}\r\n\r\n// Fetch trend data for a specific metric at a specific location\r\nexport const fetchTrendData = async (\r\n  locationId: string, \r\n  metric: string, \r\n  months = 12\r\n): Promise<TrendResponse> => {\r\n  try {\r\n    // DEBUG: Log the exact metric name being passed in\r\n    console.log(`TrendAPI: fetchTrendData called with metric: \"${metric}\" (length: ${metric.length})`);\r\n    console.log(`TrendAPI: metric character codes:`, metric.split('').map(c => `${c}(${c.charCodeAt(0)})`).join(' '));\r\n    \r\n    // CRITICAL: Do not transform the metric name at all - use exactly as passed\r\n    const trendsUrl = `${API_BASE_URL}/api/locationMetrics/trends/${locationId}/${metric}?months=${months}`;\r\n    console.log('üîç TrendAPI: Attempting to fetch trends from:', trendsUrl);\r\n    \r\n    const trendsResponse = await fetch(trendsUrl);\r\n    console.log('Trends response status:', trendsResponse.status);\r\n    console.log('Trends response headers:', Object.fromEntries(trendsResponse.headers.entries()));\r\n    \r\n    if (trendsResponse.ok) {\r\n      const responseText = await trendsResponse.text();\r\n      console.log('Raw response text:', responseText.substring(0, 200) + '...');\r\n      \r\n      // Check if response looks like HTML (error page)\r\n      if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {\r\n        console.error('üö® TrendAPI: Got HTML response instead of JSON - API endpoint not found!');\r\n        console.error('üö® TrendAPI: Check if your API routes are properly configured');\r\n        throw new Error('API endpoint returned HTML instead of JSON');\r\n      }\r\n      \r\n      try {\r\n        const result = JSON.parse(responseText);\r\n        console.log('‚úÖ TrendAPI: Successfully parsed JSON response');\r\n        console.log('‚úÖ TrendAPI: Current value from API:', result.data?.currentValue);\r\n        console.log('‚úÖ TrendAPI: Current period from API:', result.data?.currentPeriod);\r\n        \r\n        // Validate the response structure\r\n        if (result.data && Array.isArray(result.data.dataPoints)) {\r\n          return result;\r\n        }\r\n      } catch (parseError) {\r\n        console.error('‚ùå TrendAPI: JSON parsing failed:', parseError);\r\n        console.log('‚ùå TrendAPI: Response was not valid JSON, probably got HTML instead');\r\n      }\r\n    }\r\n\r\n    // If trends endpoint doesn't exist, fall back to building trends from uploaded data\r\n    console.log('‚ö†Ô∏è TrendAPI: Building trend data from uploaded scorecards...');\r\n    return await buildTrendFromUploadedData(locationId, metric, months);\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå TrendAPI: Error fetching trend data:', error);\r\n    // Fall back to building from uploaded data\r\n    return await buildTrendFromUploadedData(locationId, metric, months);\r\n  }\r\n};\r\n\r\n// Build trend data from actual uploaded scorecard data\r\nconst buildTrendFromUploadedData = async (\r\n  locationId: string, \r\n  metric: string, \r\n  months: number\r\n): Promise<TrendResponse> => {\r\n  try {\r\n    console.log(`üîß TrendAPI: Building trend for metric \"${metric}\" at location \"${locationId}\"`);\r\n    \r\n    // Fetch the actual history of uploaded scorecards\r\n    const historyUrl = `${API_BASE_URL}/api/locationMetrics/history`;\r\n    console.log('Fetching upload history from:', historyUrl);\r\n    \r\n    const historyResponse = await fetch(historyUrl);\r\n    console.log('History response status:', historyResponse.status);\r\n    \r\n    if (!historyResponse.ok) {\r\n      throw new Error(`Failed to fetch upload history: ${historyResponse.status}`);\r\n    }\r\n\r\n    const responseText = await historyResponse.text();\r\n    console.log('History raw response:', responseText.substring(0, 200) + '...');\r\n    \r\n    // Check if response looks like HTML\r\n    if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {\r\n      console.error('History API returned HTML instead of JSON');\r\n      throw new Error('History API returned HTML instead of JSON');\r\n    }\r\n    \r\n    let historyData;\r\n    try {\r\n      historyData = JSON.parse(responseText);\r\n    } catch (parseError) {\r\n      console.error('Failed to parse history response as JSON:', parseError);\r\n      throw new Error('History API returned non-JSON response (probably HTML redirect)');\r\n    }\r\n    \r\n    if (!historyData.success || !historyData.data || !Array.isArray(historyData.data.history)) {\r\n      throw new Error('No upload history available');\r\n    }\r\n\r\n    const uploadedMonths = historyData.data.history;\r\n    console.log(`Found ${uploadedMonths.length} actual uploaded months:`, uploadedMonths.map((u: any) => `${u.month} ${u.year}`));\r\n\r\n    if (uploadedMonths.length === 0) {\r\n      throw new Error('No uploaded scorecard data found');\r\n    }\r\n\r\n    // Sort uploads by date to ensure proper chronological order\r\n    uploadedMonths.sort((a: any, b: any) => {\r\n      const dateA = new Date(a.year, getMonthNumber(a.month) - 1);\r\n      const dateB = new Date(b.year, getMonthNumber(b.month) - 1);\r\n      return dateA.getTime() - dateB.getTime();\r\n    });\r\n\r\n    // Now fetch the actual data for each uploaded month\r\n    const dataPoints: TrendDataPoint[] = [];\r\n    \r\n    for (const upload of uploadedMonths) {\r\n      try {\r\n        // For now, we'll use the current endpoint to get the latest data\r\n        // In a real implementation, we'd need an endpoint that returns historical data by month/year\r\n        console.log(`Fetching data for ${upload.month} ${upload.year} (ID: ${upload.id})`);\r\n        \r\n        // Since we don't have a month-specific endpoint yet, we can only show the current/latest data\r\n        // This is a limitation that needs to be addressed in the backend\r\n        const response = await fetch(`${API_BASE_URL}/api/locationMetrics`);\r\n        \r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          let locations: any[] = [];\r\n          \r\n          if (data && typeof data === 'object') {\r\n            if ('locations' in data) {\r\n              locations = data.locations;\r\n            } else if ('data' in data && data.data && 'locations' in data.data) {\r\n              locations = data.data.locations;\r\n            }\r\n          }\r\n\r\n          const location = locations.find((loc: any) => \r\n            loc.name?.toLowerCase().replace(/\\s+/g, '-') === locationId ||\r\n            loc.locationId === locationId\r\n          );\r\n\r\n          if (location) {\r\n            const value = extractMetricValue(location, metric);\r\n            \r\n            if (value !== null) {\r\n              const uploadDate = new Date(upload.year, getMonthNumber(upload.month) - 1, 1);\r\n              \r\n              dataPoints.push({\r\n                month: upload.month,\r\n                year: upload.year,\r\n                value: value,\r\n                uploadDate: uploadDate.toISOString()\r\n              });\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.warn(`Failed to fetch data for ${upload.month} ${upload.year}:`, error);\r\n      }\r\n    }\r\n\r\n    if (dataPoints.length === 0) {\r\n      throw new Error(`No data found for metric ${metric} at location ${locationId}`);\r\n    }\r\n\r\n    console.log(`Built trend with ${dataPoints.length} REAL data points:`, dataPoints.map(p => `${p.month} ${p.year}: ${p.value}`));\r\n\r\n    // Calculate trend analysis from actual data\r\n    const firstValue = dataPoints[0]?.value || 0;\r\n    const lastValue = dataPoints[dataPoints.length - 1]?.value || 0;\r\n    const trendDirection = lastValue - firstValue;\r\n    \r\n    const analysis = {\r\n      averageChange: dataPoints.length > 1 ? trendDirection / (dataPoints.length - 1) : 0,\r\n      volatility: calculateVolatility(dataPoints),\r\n      bestMonth: dataPoints.reduce((best, current) => current.value > best.value ? current : best, dataPoints[0]),\r\n      worstMonth: dataPoints.reduce((worst, current) => current.value < worst.value ? current : worst, dataPoints[0]),\r\n      currentVsPrevious: dataPoints.length > 1 ? lastValue - dataPoints[dataPoints.length - 2].value : 0\r\n    };\r\n\r\n    return {\r\n      success: true,\r\n      data: {\r\n        metric,\r\n        locationId,\r\n        currentValue: lastValue,\r\n        currentPeriod: `${dataPoints[dataPoints.length - 1]?.month} ${dataPoints[dataPoints.length - 1]?.year}`,\r\n        trend: trendDirection > 2 ? 'improving' : trendDirection < -2 ? 'declining' : 'stable',\r\n        trendDirection,\r\n        dataPoints,\r\n        monthsOfData: dataPoints.length,\r\n        analysis\r\n      }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå TrendAPI: Error building trend from actual uploaded data:', error);\r\n    // Return empty response - NO FAKE DATA\r\n    return {\r\n      success: false,\r\n      data: {\r\n        metric,\r\n        locationId,\r\n        currentValue: 0,\r\n        currentPeriod: 'No data',\r\n        trend: 'stable',\r\n        trendDirection: 0,\r\n        dataPoints: [],\r\n        monthsOfData: 0,\r\n        analysis: {\r\n          averageChange: 0,\r\n          volatility: 0,\r\n          bestMonth: { month: '', year: 0, value: 0, uploadDate: '' },\r\n          worstMonth: { month: '', year: 0, value: 0, uploadDate: '' },\r\n          currentVsPrevious: 0\r\n        }\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n// Helper function to convert month name to number\r\nconst getMonthNumber = (monthName: string): number => {\r\n  const months = [\r\n    'January', 'February', 'March', 'April', 'May', 'June',\r\n    'July', 'August', 'September', 'October', 'November', 'December'\r\n  ];\r\n  return months.indexOf(monthName) + 1;\r\n};\r\n\r\n// Extract metric value from location data - PRESERVE EXACT METRIC NAMES\r\nconst extractMetricValue = (location: any, metric: string): number | null => {\r\n  console.log(`üîç TrendAPI: Extracting value for metric \"${metric}\" from location data`);\r\n  console.log(`üîç TrendAPI: Available fields in location:`, Object.keys(location));\r\n  \r\n  const value = location[metric];\r\n  console.log(`üîç TrendAPI: Raw value for \"${metric}\":`, value);\r\n  \r\n  if (value === undefined || value === null || value === 'N/A') {\r\n    console.log(`‚ö†Ô∏è TrendAPI: No value found for metric \"${metric}\"`);\r\n    return null;\r\n  }\r\n  \r\n  // Handle percentage values\r\n  if (typeof value === 'string' && value.includes('%')) {\r\n    const parsed = parseFloat(value.replace('%', ''));\r\n    console.log(`‚úÖ TrendAPI: Parsed percentage value \"${value}\" to ${parsed}`);\r\n    return parsed;\r\n  }\r\n  \r\n  const parsed = parseFloat(value);\r\n  console.log(`‚úÖ TrendAPI: Parsed numeric value \"${value}\" to ${parsed}`);\r\n  return isNaN(parsed) ? null : parsed;\r\n};\r\n\r\n// Calculate volatility of data points\r\nconst calculateVolatility = (dataPoints: TrendDataPoint[]): number => {\r\n  if (dataPoints.length < 2) return 0;\r\n  \r\n  const values = dataPoints.map(p => p.value);\r\n  const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\r\n  \r\n  return Math.sqrt(variance);\r\n};\r\n\r\n// Fetch all historical data across all locations\r\nexport const fetchHistoricalData = async (): Promise<HistoricalDataResponse> => {\r\n  try {\r\n    // First, get the upload history to see what months are available\r\n    const historyResponse = await fetch(`${API_BASE_URL}/api/locationMetrics/history`);\r\n    \r\n    if (!historyResponse.ok) {\r\n      console.warn(`Backend history endpoint not available (${historyResponse.status})`);\r\n      return {\r\n        success: false,\r\n        data: { locations: [] }\r\n      };\r\n    }\r\n\r\n    const historyData = await historyResponse.json();\r\n    \r\n    if (!historyData.success || !historyData.data || !Array.isArray(historyData.data.history)) {\r\n      console.warn('No upload history available');\r\n      return {\r\n        success: false,\r\n        data: { locations: [] }\r\n      };\r\n    }\r\n\r\n    const uploadedMonths = historyData.data.history;\r\n    console.log(`Found ${uploadedMonths.length} actual uploaded months:`, uploadedMonths.map((u: any) => `${u.month} ${u.year}`));\r\n\r\n    // Get current data (which represents the latest upload)\r\n    const currentResponse = await fetch(`${API_BASE_URL}/api/locationMetrics`);\r\n    \r\n    if (!currentResponse.ok) {\r\n      console.warn(`Backend data endpoint not available (${currentResponse.status})`);\r\n      return {\r\n        success: false,\r\n        data: { locations: [] }\r\n      };\r\n    }\r\n\r\n    const currentData = await currentResponse.json();\r\n    let locations: any[] = [];\r\n    \r\n    if (currentData && typeof currentData === 'object') {\r\n      if ('locations' in currentData) {\r\n        locations = currentData.locations;\r\n      } else if ('data' in currentData && currentData.data && 'locations' in currentData.data) {\r\n        locations = currentData.data.locations;\r\n      }\r\n    }\r\n\r\n    if (!Array.isArray(locations) || locations.length === 0) {\r\n      console.warn('No location data found in response');\r\n      return {\r\n        success: false,\r\n        data: { locations: [] }\r\n      };\r\n    }\r\n\r\n    // Transform data to show ONLY the actual uploaded months\r\n    // Note: Currently we can only get the latest month's data due to backend limitations\r\n    const historicalLocations = locations.map(location => {\r\n      // For now, we can only show one upload (the latest) since the backend doesn't store historical values per month\r\n      // This is a limitation that should be addressed by storing monthly snapshots in the backend\r\n      const uploads = [{\r\n        month: currentData.data?.month || new Date().toLocaleDateString('en-US', { month: 'long' }),\r\n        year: currentData.data?.year || new Date().getFullYear(),\r\n        uploadDate: currentData.data?.uploadedAt || new Date().toISOString(),\r\n        metrics: {\r\n          vscCaseRequirements: location.vscCaseRequirements || 'N/A',\r\n          vscClosedCorrectly: location.vscClosedCorrectly || 'N/A',\r\n          ttActivation: location.ttActivation || 'N/A',\r\n          smMonthlyDwellAvg: location.smMonthlyDwellAvg || 'N/A',\r\n          triageHours: location.triageHours || 'N/A',\r\n          triagePercentLess4Hours: location.triagePercentLess4Hours || 'N/A',\r\n          etrPercentCases: location.etrPercentCases || 'N/A',\r\n          percentCasesWith3Notes: location.percentCasesWith3Notes || 'N/A',\r\n          rdsMonthlyAvgDays: location.rdsMonthlyAvgDays || 'N/A',\r\n          smYtdDwellAvgDays: location.smYtdDwellAvgDays || 'N/A',\r\n          rdsYtdDwellAvgDays: location.rdsYtdDwellAvgDays || 'N/A'\r\n        }\r\n      }];\r\n\r\n      return {\r\n        locationId: location.name?.toLowerCase().replace(/\\s+/g, '-') || 'unknown',\r\n        locationName: location.name || 'Unknown Location',\r\n        uploads\r\n      };\r\n    });\r\n    \r\n    console.log(`Historical data shows ${uploadedMonths.length} uploads available, but backend limitation means we can only display latest month's values`);\r\n    \r\n    return {\r\n      success: true,\r\n      data: { locations: historicalLocations }\r\n    };\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching historical data:', error);\r\n    return {\r\n      success: false,\r\n      data: { locations: [] }\r\n    };\r\n  }\r\n};\r\n\r\n// Fetch comparison data across locations and time periods\r\nexport const fetchComparisonData = async (\r\n  months = 6, \r\n  locationId?: string\r\n): Promise<ComparisonResponse> => {\r\n  try {\r\n    // First try the dedicated comparison endpoint\r\n    const params = new URLSearchParams({ months: months.toString() });\r\n    if (locationId) {\r\n      params.append('locationId', locationId);\r\n    }\r\n    \r\n    const comparisonResponse = await fetch(\r\n      `${API_BASE_URL}/api/locationMetrics/compare?${params}`\r\n    );\r\n    \r\n    if (comparisonResponse.ok) {\r\n      const result = await comparisonResponse.json();\r\n      if (result.success && result.data) {\r\n        return result;\r\n      }\r\n    }\r\n\r\n    // If comparison endpoint doesn't exist, build comparison from current data\r\n    console.log('Building comparison data from current scorecard data...');\r\n    return await buildComparisonFromCurrentData(months, locationId);\r\n    \r\n  } catch (error) {\r\n    console.error('Error fetching comparison data:', error);\r\n    // Fall back to building from current data\r\n    return await buildComparisonFromCurrentData(months, locationId);\r\n  }\r\n};\r\n\r\n// Build comparison data from current uploaded scorecard data\r\nconst buildComparisonFromCurrentData = async (\r\n  months: number,\r\n  locationId?: string\r\n): Promise<ComparisonResponse> => {\r\n  try {\r\n    // Get upload history to see what months are actually available\r\n    const historyResponse = await fetch(`${API_BASE_URL}/api/locationMetrics/history`);\r\n    \r\n    if (!historyResponse.ok) {\r\n      console.warn(`Backend history endpoint not available (${historyResponse.status})`);\r\n      return {\r\n        success: false,\r\n        data: { metrics: [] }\r\n      };\r\n    }\r\n\r\n    const historyData = await historyResponse.json();\r\n    \r\n    if (!historyData.success || !historyData.data || !Array.isArray(historyData.data.history)) {\r\n      console.warn('No upload history available for comparison');\r\n      return {\r\n        success: false,\r\n        data: { metrics: [] }\r\n      };\r\n    }\r\n\r\n    const uploadedMonths = historyData.data.history;\r\n    console.log(`Building comparison from ${uploadedMonths.length} actual uploaded months`);\r\n\r\n    // Fetch current data (represents latest upload)\r\n    const response = await fetch(`${API_BASE_URL}/api/locationMetrics`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch current data: ${response.status}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    let locations: any[] = [];\r\n    \r\n    // Handle different response structures\r\n    if (data && typeof data === 'object') {\r\n      if ('locations' in data) {\r\n        locations = data.locations;\r\n      } else if ('data' in data && data.data && 'locations' in data.data) {\r\n        locations = data.data.locations;\r\n      }\r\n    }\r\n\r\n    if (!Array.isArray(locations)) {\r\n      throw new Error('No location data available');\r\n    }\r\n\r\n    // Filter by specific location if requested\r\n    if (locationId && locationId !== 'all') {\r\n      locations = locations.filter(loc => \r\n        loc.name?.toLowerCase().replace(/\\s+/g, '-') === locationId\r\n      );\r\n    }\r\n\r\n    // Build metrics comparison structure - only using real uploaded data\r\n    const availableMetrics = ['vscCaseRequirements', 'vscClosedCorrectly', 'ttActivation', \r\n                             'smMonthlyDwellAvg', 'triageHours', 'triagePercentLess4Hours'];\r\n    \r\n    const metrics = availableMetrics.map(metricKey => ({\r\n      metric: metricKey,\r\n      locations: locations.map(location => {\r\n        const currentValue = extractMetricValue(location, metricKey) || 0;\r\n        return {\r\n          locationId: location.name?.toLowerCase().replace(/\\s+/g, '-') || 'unknown',\r\n          locationName: location.name || 'Unknown Location',\r\n          trendData: [], // Empty since backend doesn't store historical snapshots yet\r\n          currentValue,\r\n          trend: 'stable' // No trend calculation possible with single data point\r\n        };\r\n      })\r\n    }));\r\n\r\n    console.log(`Comparison limited to current values. Historical trends require ${uploadedMonths.length} monthly snapshots.`);\r\n\r\n    return {\r\n      success: true,\r\n      data: { metrics }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('Error building comparison from current data:', error);\r\n    return {\r\n      success: false,\r\n      data: { \r\n        metrics: []\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\n// Calculate trend direction and analysis from data points\r\nexport const calculateTrend = (dataPoints: TrendDataPoint[]): {\r\n  trend: 'improving' | 'declining' | 'stable';\r\n  direction: number;\r\n  confidence: number;\r\n} => {\r\n  if (dataPoints.length < 2) {\r\n    return { trend: 'stable', direction: 0, confidence: 0 };\r\n  }\r\n\r\n  // Calculate simple linear regression slope\r\n  const n = dataPoints.length;\r\n  const xValues = dataPoints.map((_, index) => index);\r\n  const yValues = dataPoints.map(point => point.value);\r\n  \r\n  const sumX = xValues.reduce((a, b) => a + b, 0);\r\n  const sumY = yValues.reduce((a, b) => a + b, 0);\r\n  const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);\r\n  const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);\r\n  \r\n  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\r\n  \r\n  // Calculate confidence based on R-squared\r\n  const meanY = sumY / n;\r\n  const totalSumSquares = yValues.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);\r\n  const predictedValues = xValues.map(x => (sumY / n) + slope * (x - sumX / n));\r\n  const residualSumSquares = yValues.reduce((sum, y, i) => sum + Math.pow(y - predictedValues[i], 2), 0);\r\n  const rSquared = 1 - (residualSumSquares / totalSumSquares);\r\n  \r\n  // Determine trend based on slope and confidence\r\n  const confidence = Math.max(0, Math.min(1, rSquared));\r\n  const threshold = 0.1; // Minimum slope threshold for trend detection\r\n  \r\n  if (Math.abs(slope) < threshold || confidence < 0.3) {\r\n    return { trend: 'stable', direction: slope, confidence };\r\n  }\r\n  \r\n  return {\r\n    trend: slope > 0 ? 'improving' : 'declining',\r\n    direction: slope,\r\n    confidence\r\n  };\r\n};\r\n\r\n// Get trend icon based on trend type\r\nexport const getTrendIcon = (trend: string): string => {\r\n  switch (trend) {\r\n    case 'improving': return 'üìà';\r\n    case 'declining': return 'üìâ';\r\n    case 'stable': return 'üìä';\r\n    default: return 'üìä';\r\n  }\r\n};\r\n\r\n// Get trend color class based on trend type\r\nexport const getTrendColorClass = (trend: string): string => {\r\n  switch (trend) {\r\n    case 'improving': return 'text-green-600';\r\n    case 'declining': return 'text-red-600';\r\n    case 'stable': return 'text-blue-600';\r\n    default: return 'text-gray-600';\r\n  }\r\n};\r\n\r\n// Format trend analysis for display\r\nexport const formatTrendAnalysis = (analysis: TrendAnalysis): string => {\r\n  const { trend, analysis: data, monthsOfData } = analysis;\r\n  \r\n  if (monthsOfData < 2) {\r\n    return 'Insufficient data for trend analysis';\r\n  }\r\n  \r\n  const changeText = data.currentVsPrevious > 0 ? 'increased' : 'decreased';\r\n  const changePercent = Math.abs(data.currentVsPrevious).toFixed(1);\r\n  \r\n  switch (trend) {\r\n    case 'improving':\r\n      return `üìà Improving trend over ${monthsOfData} months. ${changeText} ${changePercent}% from previous month.`;\r\n    case 'declining':\r\n      return `üìâ Declining trend over ${monthsOfData} months. ${changeText} ${changePercent}% from previous month.`;\r\n    case 'stable':\r\n      return `üìä Stable performance over ${monthsOfData} months with minimal variation.`;\r\n    default:\r\n      return `Data available for ${monthsOfData} months.`;\r\n  }\r\n};\r\n\r\n// Add connection test function\r\nexport const testBackendConnection = async (): Promise<boolean> => {\r\n  try {\r\n    console.log('Testing backend connection...');\r\n    \r\n    const testUrl = `${API_BASE_URL}/api/locationMetrics`;\r\n    const response = await fetch(testUrl);\r\n    \r\n    console.log('Backend test response:', response.status);\r\n    \r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      console.log('Backend is responding with JSON data');\r\n      console.log('Available locations:', data.data?.locations?.length || 0);\r\n      \r\n      // Test metric extraction to verify values are landing on correct cards\r\n      if (data.data?.locations?.length > 0) {\r\n        const firstLocation = data.data.locations[0];\r\n        console.log('Testing metric extraction for first location:');\r\n        console.log('VSC Case Requirements:', firstLocation.vscCaseRequirements);\r\n        console.log('VSC Closed Correctly:', firstLocation.vscClosedCorrectly);\r\n        console.log('TT+ Activation:', firstLocation.ttActivation);\r\n        console.log('SM Monthly Dwell Avg:', firstLocation.smMonthlyDwellAvg);\r\n        console.log('SM YTD Dwell Avg Days:', firstLocation.smYtdDwellAvgDays);\r\n        console.log('Triage % < 4 Hours:', firstLocation.triagePercentLess4Hours);\r\n        console.log('Triage Hours:', firstLocation.triageHours);\r\n        console.log('ETR % Cases:', firstLocation.etrPercentCases);\r\n        console.log('% Cases with 3+ Notes:', firstLocation.percentCasesWith3Notes);\r\n        console.log('RDS Monthly Avg Days:', firstLocation.rdsMonthlyAvgDays);\r\n        console.log('RDS YTD Dwell Avg Days:', firstLocation.rdsYtdDwellAvgDays);\r\n      }\r\n      \r\n      return true;\r\n    } else {\r\n      console.log('Backend returned error status:', response.status);\r\n      return false;\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('Backend connection test failed:', error);\r\n    return false;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}